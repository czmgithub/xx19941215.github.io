---
layout:     post
title:      "5.5 Function类型"
subtitle:   "好记性不如烂笔头"
date:       2016-01-02 20:19:00
author:     "Xiao"
header-img: "img/post-bj-jspro.jpg"
tags:
    - Javascript
---

>好记性不如烂笔头.


函数实际上是对象，每个函数都是Function类型的实例。与其他引用类型都一样具有属性和方法。由于函数是对象，所以每一个函数名都是指向函数对象的指针，不会与某个函数对象绑定。

### 1.函数的定义方法

- 使用函数声明语法:

```javascript
function sum(num1,num2){
   return num1+num2; 
}
```
- 使用函数表达式

```javascript
var sum=function(num1,xum2){ 
  return num1+num2; 
  };//结尾要有分号，就像声明其他变量一样
  
```

- 使用Function构造函数

```javascript
var sum=Function("num1","num2","return num1+num2");//不推荐
```

由于函数名是指针，所以和其他包含对象指针的变量没有什么区别。也就是说一个函数可以有多个名字，例如：

```javascript
function sum(num1,num2){
	return num1+num2;
}
alert(sum(10,10));//20

var xiaoxiao=sum;
alert(xiaoxiao(10,10));//20

sum=null;
alert(xiaoxiao(10,10));//20
```

### 2.ECMAscript没有重载

### 3.函数声明和函数表达式的区别

```javascript
alert(sum(10,10));//20
function sum(num1,num2){
	return num1+num2;
}
```

以上的代码可以正常运行，但下面的会产生错误

```javascript
alert(sum(10,10));
var sum=function(num1,num2){
	return num1+num2;
}
```

原因是在代码开始执行的时候，js解析器通过一个叫做“函数声明提升”的过程将函数声明添加到了执行环境中。

除此之外，他们没有什么区别。甚至可以一起用，例如：

```javascript
var sum=function sum(){}
```

但遗憾的是，在safari中会产生错误。

### 4.作为值存在的函数

因为ECMAscript中的函数名本身就是变量，所以函数也可以作为值来使用。函数可以作为参数来传递给另外一个函数，也可以作为值返回。看下面的例子：

```javascript
function callSomeFunction(someFunction,someArguement){
	return someFunction(someArgue);
}

function add10(num){
	return num+10;
}

var result1=callSomeFunction(add10,10);
alert(result1);//20
```

### 5.函数内部属性

在函数内有两个特殊对象：arguments和this。

arguments是一个类数组对象，包含着传入函数的所有参数。这个对象还有一个callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。看下面这个经典的递归函数

```javascript
function factorial(num){
	if(num<1){
		return 1;
	}else{
		return num*factorial(num-1)
	}
}
```

但是这个函数的执行和函数名耦合在了一起。可以使用下面的方法解决

```javascript
function factorial(num){
	if(num<1){
		return 1;
	}else{
		return num*arguements.callee(num-1)
	}
}
```

现在即使这样使用这个递归函数，都没有问题

```javascript
var xiaoxiao=factorial;
factorial=function(){
	return 0;
};

alert(xiaoxiao(5));//120
alert(factorial(5));//0
```

this 是指函数运行的环境对象，在网页的全局作用域中调用时，this指的是window

ECMAscript5也规范了另一个函数对象的属性：caller。除了Opera早期版本不支持，其他都支持。
这个属性保存着当前函数的引用，如果实在全局作用域调用当前函数，它的值为null。因为当前window没有引用对象

例如：

```javascript
function outer() {
	inner();
}

function inner(){
	alert(inner.caller);
	//这里可以使用alert(arguments.callee.caller);实现更加松散的耦合
}

outer();

```
IE Firefox Chrome和Safari的所有版本和Opera9.6都支持caller属性


当在严格模式下访问时，访问arguments.caller会导致错误。ECMAscript5还定义了arguments.caller属性，但是在严格模式下访问他也会导致错误，在非严格模式下访问这个属性始终是undefined。严格模式还有一个限制，不能为函数的caller属性赋值，否则会导致错误。

